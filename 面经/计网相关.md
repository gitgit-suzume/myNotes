> 计算机网络相关

## 一次完整的http请求

* 输入url
* dns解析
    * 有缓存(只有get请求会被缓存，post不会)，直接读取(根据Etag、Expires、Cache-Control判断是否有缓存/过期，没过期返回304)
    * 没有缓存进行dns查询
* 发起tcp3次握手
    * 客户端SYN=1，Seq=x+1
    * 服务端SYN=1，Seq=y+1，ACK=x+1
    * 客户端Ack=y+1，Seq=x+2
* 建立连接完成后，发送HTTP请求
* 服务端相应HTTP请求，返回页面
* 浏览器获取页面
    * HTML转DOM
    * CSS转CSSDOM
    * DOM+CSSDOM=渲染树
    * 生成布局，把所有渲染树节点进行平面合成
    * 将布局绘制在屏幕上
* 浏览器显示页面

> 断开TCP连接的tcp四次握手

* 第一次握手：主动关闭方发送一个FIN，用于关闭主动方到被动方的数据传输。不过FIN发送之前发送的报文如果没有收到ACK确认报文，主动关闭方依旧会重发数据，且此时主动关闭方还能接收数据
* 第二次握手：被动关闭方收到FIN后，发一个ACK给主动关闭方，确认序号+1
* 第三次握手：被动关闭方发送一个FIN，用来关闭被动关闭方与主动关闭方的数据传输，同时也是告诉主动关闭方我不会再给你传数据了
* 第四次握手，主动关闭方收到FIN后，发送ACK给被动关闭方，序号+1。

## TCP和UDP区别

* TCP 基于连接、可靠、耗时（三次握手）
* UDP 非连接、不可靠、耗时低

> Etag--判断文件是否在上一次请求之后修改
    Etag主要为了解决last-Modified无法解决的问题
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断，浏览器根据缓存过期时间判断缓存文件是否过期。
    * 若没有过期，则不向服务器发送请求，直接使用缓存中的结果。此时控制台报200，浏览器和服务器没有任何交互
    * 已经过期，向服务器发送请求，带上上一点中设置的文件修改时间和etag。随后进行资源更新判断，根据文件修改时间，判断浏览器自上一次请求后有没有修改过文件；根据etag，判断自上一次请求后有没有发生变化
        * 情景一，两种判断都是文件没有被修改过，则服务器不发送文件给浏览器，告诉浏览器文件没有修改过--304
        * 情景二，不满足情景一的其余情况，服务器会受理此次请求。

> Expires 和 Cache-Control -- 过期时间判断？
* Expires要求客户端服务端时钟严格同步，http1.1引入Cache-Control客服Expires头的限制
* 如果max-age和Expires同时出现，则max-gae有更高优先级
* 如果服务器同时设置Expires和Cache-Control，则都用

```bash
//一次打开某度的请求头片段
Cache-Control: private, max-age = 0
Etag: "1ec5-502264e2ae4c0"
Expires: Sun, 25 Feb 2018 01:53:24 GMT
Last-Modified: Sun, 25 Feb 2018 01:53:24 GMT
//资料还提及Pragma: private。不过我没看见
//Pragma: private
```

```bash
//设置expires
document.cookie = `expires=${new Date(0)}`
```

## http、https、http2

参考(https://zhuanlan.zhihu.com/p/24913080)
* http
```bash
* 请求头
    * Accept：指定客户端能够接收的内容类型。
    * Accept-Encoding：表示浏览器有能力解码的编码类型。
    * Accept-Language：表示浏览器所支持的语言类型。
    * Cache-Control：指定请求和响应遵循的缓存机制。
    * Connection：表示是否需要持久连接。
    * Cookie：用于会话追踪，在本文后面就继续介绍。
    * Host：表示请求的服务器网址
    * User-Agent：用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户端使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。
    * Content-Length: 请求的内容长度
    * Referer: 先前访问的网页的地址，当前请求网页紧随其后，说明你是先前是从哪个网址点击访问到该页面的，如果没有则不填。
    * Content-Type：内容的类型，GET 请求无该字段，POST 请求中常见的有 application/x-www-form-urlencoded 为普通的表单提交，还有文件上传为 multipart/form-data
* 响应头
    * Date：原始服务器消息发出的时间。
    * Last-Modified：请求资源的最后修改时间。
    * Expires：响应过期的日期和时间，如果下次访问在时间允许的范围内，可以不用重新请求，直接访问缓存。
    * Set-Cookie: 设置Http Cookie，下次浏览器再次访问的时候会带上这个 Cookie 值。
    * Server：服务器软件名称，常见的有 Apache 和 Nginx。
* 会话追踪
    因为htpp是无状态无连接的，所以需要会话追踪，以便下一次请求能判断是否为同一用户
    方法：
    * url重写：在url结尾加个数据以标识当前会话
    * 隐藏表单域：将会话id添加到html表单元素中
    * cookie：临时cookie和存在磁盘上的cookie（有过期时间）。以及cookie可能被用户禁用
    * session：存在于服务端，将sessionID标识session对象，存在cookie中发给客户端，客户端下一次请求带上。
* keep-alive
    客户端浏览器支持keep-alive的话，在请求头加上，告诉服务端，服务端返回的请求也标着keep-alive。这样客户端和服务端的http连接就会被保持（超过keep-alive规定时间、意外断电等情况除外）
    在http1.1规定的，跟1.0的无状态无连接不矛盾。

无连接无状态、构建与TCP/IP协议之上，默认端口号为80。
服务器交互常用方式POST、GET、PUT、DELETE
一个 URL 地址，对应着一个网络上的资源
HTTP 请求由 3 个部分构成，分别是：状态行，请求头(Request Header)，请求正文
```
    * https
```bash
    http缺点
    1.明文传输
    2.通信双发没有进行任何验证
    http后果
    1.通信过程容易被监听、劫持、篡改
    2.比如将广告连接嵌入到服务器发送给用户的http报文中
    3.修改用户请求头url，导致用户请求被劫持到另一个王钊，用户请求永远到不了真正的服务器

    http保证安全
    1.加密、身份验证（对称密钥）——非对称加密算法（公钥私钥）交换对称密钥+数字证书验证十分（验证公钥是否伪造）+利用对称密钥加解密后续传输的数据=安全
    2.非对称加密算法里，公钥加密数据，有且只有唯一的私钥才能解密。
    服务端把公钥发给客户端，客户端利用公钥加密对称密钥后返还给服务端，服务端用私钥机密，就可以拿到加密用的对称密钥。
    3.非对称加密可以很好地管理对称密钥，保证每次数据加密的对称密钥都是不同的。
    4.攻击，服务器发送公钥给客户端，被中间人截获，掉包公钥后发给客户端，
    客户端用掉包的公钥加密对称密钥发给客户端，依旧被中间人截获，
    中间人用掉包公钥解密对称密钥，然后把对称密钥用正确的公钥发给服务端。
    5.解决方法：数字证书——服务端生成公钥私钥，将其给相关机关，相关机关将其放入数字证书并将数字证书发给服务器。
    此时服务器不是简单地把公钥给客户端，而是把数字证书给客户端。以此保证客户端拿到的公钥是来自服务端的
```
    * http/2
```bash
    1.将请求数据和相应数据分割为更小的帧，并且他们采用二进制编码
    2.同域名下所有通信都在单个连接上完成
        该链接可承载任意数量的双向数据流
        数据流以消息形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为帧首部的流标识可重新组装
    3.多路复用，代替原来的序列和阻塞机制，所有的请求都是通过一个tcp链接并发完成。
    4.服务器推送（发起页面html是主动推送其他资源，比如可以主动把js和css文件推送给客户端，而不用客户端解析html时在发送这些请求），服务器推送客户端有权选择是否接收。如果推送已经缓存可以拒绝，推送同样遵守同源策略
    5.投不压缩
```

## HTTP状态码

* 100——continue。一般在发送post请求时，已发送http header后服务端将返回此信息，表示确认，之后在发送具体参数信息
* 200——ok。正常返回信息
* 201——created。请求成功且服务器创建了新的资源。
* 202——Accepted。服务器已接受请求，但尚未处理
* 301——Moved Permanently。请求网页已永久挪动到新位置
* 302——found。临时性重定向
* 303——see other。临时性重定向，且总是用get请求新的url
* 304——not modified。服自从上次请求后，请求网页未修改过。
//4开头的前端一般发错数据（包括数据不存在、数据格式错误等）
* 400——bad request。服务器无法理解请求格式
* 401——unauthorized。请求未授权
* 403——forbidden。禁止访问
* 404——not found。这个前端最好做一个404页面备着，而不是让控制台报这种错误
//5开头一般表示后台崩了、服务器关闭等
* 500——internal server error。最常见的服务端错误
* 503——service unavailable。服务端暂时无法处理请求（可能服务端过载、关闭、维护中）

## GET && POST

* GET
    * 一般用于信息获取
    * 使用url传递参数
    * 对所发信息大小有限制，一般为2000个字符
* POST
    * 用于修改服务器上资源，对发送信息没有限制
    * 通过提交表单传输

###### POST使用场景：

* 无法使用缓存文件（更新服务器上的文件或数据库）
* 向服务器发送大量数据
* 发送函未知字符串的用户输入时，post比get更稳定、可靠

## 网络分层里七层模型
* 应用层：应用层、表示层、会话层（从上往下HTTP、FTP、SMTP、DNS）
    * 应用层： 允许防伪osi环境的手段（应用协议数据单元APDU）
    * 表示层：对数据进行翻译、加密、压缩（表示协议数据单元PPDU）
    * 会话层：简历、管理、终止会话（会话协议数据单元SPDU）
* 传输层（TCP、UDP）
    * 传输层：提供端到端的可靠报文传递和错误回复（段）
* 网络层（IP）
    * 网络层：负责数据包从源到宿的传递和网际互联（包）
* 物理层和数据链路层（以太网）
     * 数据链路层： 将比特组装成帧，和点到点的传递（帧）
     * 物理层： 通过没接传输比特，确定机械及电器规范（比特）

## 协议
* ICMP协议
    * 用于在IP主机、路由器之间传递控制消息
    * 因特网控制报文协议，是TCP/IP协议族的一个子协议
* TFTP协议
    * 用来在客户机与服务器之间进行简单文件传输协议
    * 提供不复杂、开销不大的文件传输服务
    * TCP/IP协议族中的一个
* HTTP
    * 超文本传输协议
    * 属于应用层的面向对象的协议
    * 简介、快速，适用于分布式超媒体信息系统
* DHCP
    * 动态主机配置协议
    * 一种让系统得意连接到网络上，并获取所需要的配置参数手段